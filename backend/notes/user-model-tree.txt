USER MODEL - COMPLETE TREE MAP
==============================

ğŸ“„ backend/src/models/User.js (USER DATABASE MODEL)
â”œâ”€â”€ ğŸ”§ IMPORTS
â”‚   â”œâ”€â”€ import mongoose from "mongoose";
â”‚   â””â”€â”€ import bcrypt from "bcryptjs"
â”‚
â”œâ”€â”€ ğŸ“‹ SCHEMA DEFINITION: userSchema
â”‚   â”œâ”€â”€ ğŸ”¤ fullName
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â””â”€â”€ required: true
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“§ email
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â”œâ”€â”€ required: true
â”‚   â”‚   â””â”€â”€ unique: true
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ” password
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â”œâ”€â”€ required: true
â”‚   â”‚   â””â”€â”€ minlength: 6
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ bio
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â””â”€â”€ default: ""
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ–¼ï¸ profilePicture
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â””â”€â”€ default: ""
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸŒ nativeLanguage
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â””â”€â”€ default: ""
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“š learningLanguage
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â””â”€â”€ default: ""
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ location
â”‚   â”‚   â”œâ”€â”€ type: String
â”‚   â”‚   â””â”€â”€ default: ""
â”‚   â”‚
â”‚   â”œâ”€â”€ âœ… isOnboarding
â”‚   â”‚   â”œâ”€â”€ type: Boolean
â”‚   â”‚   â””â”€â”€ default: false
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ‘¥ friends
â”‚   â”‚   â”œâ”€â”€ type: [mongoose.Schema.Types.ObjectId]
â”‚   â”‚   â””â”€â”€ ref: "User"
â”‚   â”‚
â”‚   â””â”€â”€ â° timestamps: true
â”‚       â”œâ”€â”€ createdAt: Date
â”‚       â””â”€â”€ updatedAt: Date
â”‚
â”œâ”€â”€ ğŸ” PRE-SAVE MIDDLEWARE: userSchema.pre("save")
â”‚   â”œâ”€â”€ ğŸ” CONDITION CHECK
â”‚   â”‚   â””â”€â”€ if(!this.isModified("password"))
â”‚   â”‚       â””â”€â”€ return next(); // Skip hashing if password unchanged
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ”’ PASSWORD HASHING
â”‚   â”‚   â”œâ”€â”€ try {
â”‚   â”‚   â”‚   â”œâ”€â”€ const salt = await bcrypt.genSalt(10);
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Generate salt with 10 rounds
â”‚   â”‚   â”‚   â”œâ”€â”€ this.password = await bcrypt.hash(this.password, salt);
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Hash password with generated salt
â”‚   â”‚   â”‚   â””â”€â”€ next();
â”‚   â”‚   â”‚       â””â”€â”€ Continue to save operation
â”‚   â”‚   â””â”€â”€ } catch (error) {
â”‚   â”‚       â””â”€â”€ next(error);
â”‚   â”‚           â””â”€â”€ Pass error to error handling
â”‚   â”‚
â”‚   â””â”€â”€ ğŸ”„ EXECUTION TRIGGERS
â”‚       â”œâ”€â”€ User.create() - New user creation
â”‚       â”œâ”€â”€ user.save() - User document save
â”‚       â””â”€â”€ User.findByIdAndUpdate() - User updates (if password changed)
â”‚
â”œâ”€â”€ ğŸ”‘ INSTANCE METHODS: userSchema.methods
â”‚   â””â”€â”€ matchPassword(enteredPassword)
â”‚       â”œâ”€â”€ ğŸ“¥ INPUT: enteredPassword (string)
â”‚       â”œâ”€â”€ ğŸ” COMPARISON: await bcrypt.compare(enteredPassword, this.password)
â”‚       â”‚   â”œâ”€â”€ Compare plain text with hashed password
â”‚       â”‚   â””â”€â”€ Returns: boolean (true if match, false otherwise)
â”‚       â””â”€â”€ ğŸ“¤ OUTPUT: boolean
â”‚
â”œâ”€â”€ ğŸ—ï¸ MODEL CREATION
â”‚   â”œâ”€â”€ const User = mongoose.model("User", userSchema);
â”‚   â””â”€â”€ Collection name: "users" (MongoDB pluralizes)
â”‚
â””â”€â”€ ğŸ“¤ EXPORT
    â””â”€â”€ export default User;

ğŸ”— RELATIONSHIPS:
================

1. SELF-REFERENCING RELATIONSHIP:
   â”œâ”€â”€ User â†’ User (friends array)
   â”œâ”€â”€ Type: One-to-Many (one user can have many friends)
   â”œâ”€â”€ Reference: mongoose.Schema.Types.ObjectId
   â””â”€â”€ Population: .populate("friends", "fields")

2. FRIEND REQUEST RELATIONSHIP:
   â”œâ”€â”€ FriendRequest â†’ User (sender, recipient)
   â”œâ”€â”€ Type: Many-to-One (many requests can point to one user)
   â””â”€â”€ Reference: mongoose.Schema.Types.ObjectId

ğŸ” SECURITY FEATURES:
====================

1. PASSWORD HASHING:
   â”œâ”€â”€ Algorithm: bcrypt
   â”œâ”€â”€ Salt Rounds: 10
   â”œâ”€â”€ Trigger: Pre-save middleware
   â””â”€â”€ Storage: Hashed password only

2. PASSWORD VALIDATION:
   â”œâ”€â”€ Minimum Length: 6 characters
   â”œâ”€â”€ Required Field: true
   â””â”€â”€ Type: String

3. EMAIL VALIDATION:
   â”œâ”€â”€ Required Field: true
   â”œâ”€â”€ Unique Constraint: true
   â””â”€â”€ Type: String

ğŸ”„ DATA FLOW:
=============

1. USER CREATION FLOW:
   â”œâ”€â”€ User.create({email, password, fullName})
   â”œâ”€â”€ Pre-save middleware triggers
   â”œâ”€â”€ Password hashed with bcrypt
   â”œâ”€â”€ User saved to database
   â””â”€â”€ User object returned

2. PASSWORD VERIFICATION FLOW:
   â”œâ”€â”€ user.matchPassword(enteredPassword)
   â”œâ”€â”€ bcrypt.compare() called
   â”œâ”€â”€ Returns true/false
   â””â”€â”€ Used in login process

3. FRIEND MANAGEMENT FLOW:
   â”œâ”€â”€ User.findByIdAndUpdate() to add/remove friends
   â”œâ”€â”€ Friends array updated
   â”œâ”€â”€ Timestamps automatically updated
   â””â”€â”€ User document returned

ğŸ“Š DATABASE OPERATIONS:
======================

1. CREATE OPERATIONS:
   â”œâ”€â”€ User.create() - Create new user
   â””â”€â”€ Triggers: Pre-save middleware

2. READ OPERATIONS:
   â”œâ”€â”€ User.findById() - Find by ID
   â”œâ”€â”€ User.findOne() - Find by criteria
   â”œâ”€â”€ User.find() - Find multiple users
   â””â”€â”€ .populate() - Populate references

3. UPDATE OPERATIONS:
   â”œâ”€â”€ User.findByIdAndUpdate() - Update by ID
   â”œâ”€â”€ User.updateOne() - Update single document
   â””â”€â”€ Triggers: Pre-save middleware (if password changed)

4. DELETE OPERATIONS:
   â”œâ”€â”€ User.findByIdAndDelete() - Delete by ID
   â””â”€â”€ User.deleteOne() - Delete single document

ğŸ” VALIDATION RULES:
===================

1. REQUIRED FIELDS:
   â”œâ”€â”€ fullName: Must be provided
   â”œâ”€â”€ email: Must be provided and unique
   â””â”€â”€ password: Must be provided and â‰¥6 characters

2. OPTIONAL FIELDS:
   â”œâ”€â”€ bio: Defaults to empty string
   â”œâ”€â”€ profilePicture: Defaults to empty string
   â”œâ”€â”€ nativeLanguage: Defaults to empty string
   â”œâ”€â”€ learningLanguage: Defaults to empty string
   â”œâ”€â”€ location: Defaults to empty string
   â””â”€â”€ isOnboarding: Defaults to false

3. ARRAY FIELDS:
   â””â”€â”€ friends: Array of ObjectIds referencing User documents

âš¡ PERFORMANCE CONSIDERATIONS:
=============================

1. INDEXING:
   â”œâ”€â”€ email: Unique index (automatic)
   â”œâ”€â”€ _id: Primary key index (automatic)
   â””â”€â”€ friends: Array index (for queries)

2. POPULATION:
   â”œâ”€â”€ Selective field population for performance
   â”œâ”€â”€ Example: .populate("friends", "fullName profilePicture")
   â””â”€â”€ Avoids loading unnecessary data

3. QUERY OPTIMIZATION:
   â”œâ”€â”€ Use .select() to limit returned fields
   â”œâ”€â”€ Use .lean() for read-only operations
   â””â”€â”€ Use aggregation for complex queries

ğŸš¨ ERROR HANDLING:
=================

1. VALIDATION ERRORS:
   â”œâ”€â”€ Required field missing
   â”œâ”€â”€ Email not unique
   â”œâ”€â”€ Password too short
   â””â”€â”€ Invalid data types

2. HASHING ERRORS:
   â”œâ”€â”€ bcrypt salt generation failure
   â”œâ”€â”€ bcrypt hash generation failure
   â””â”€â”€ Passed to error handling middleware

3. DATABASE ERRORS:
   â”œâ”€â”€ Connection issues
   â”œâ”€â”€ Query failures
   â””â”€â”€ Constraint violations

ğŸ“‹ USAGE EXAMPLES:
==================

1. CREATE USER:
   ```javascript
   const user = await User.create({
     email: "user@example.com",
     password: "password123",
     fullName: "John Doe"
   });
   ```

2. VERIFY PASSWORD:
   ```javascript
   const isMatch = await user.matchPassword("password123");
   ```

3. ADD FRIEND:
   ```javascript
   await User.findByIdAndUpdate(userId, {
     $addToSet: { friends: friendId }
   });
   ```

4. GET FRIENDS WITH POPULATION:
   ```javascript
   const user = await User.findById(userId)
     .select("friends")
     .populate("friends", "fullName profilePicture");
   ``` 